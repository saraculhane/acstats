---
output:
  pdf_document: default
  html_document: default
---
# Chapter 1: Toy Examples and Simulation 

### Simple Example: Two Random uniform Distributions

To demonstrate effectiveness of ICA at decomposing source signals and to develop a better understanding of the process conceptually,a simple toy example will be used.  The"unknown" source components in this model are just two random uniform variables in the matrix $S$, distorted by some arbitrary "unknown." \newline

Here the mixing matrix is  $A$ 

$$A = \begin{bmatrix} 1 & 1 \\ -1 & 3  \end{bmatrix}$$ .  

The known observations is the product of these two matrices, or matrix  $X$.  \newline

To test ICA, apply fastICA to this simple model and generate 5 plots: \newline
  
  $\textbf{1.}$ The pre-processed data \newline
  
  $\textbf{2.}$ Principle Component Analysis (PCA - for comparison to a different component based model) \newline
  
  $\bullet$ $\textbf{ICA components} \newline 
        
$\textbf{3.}$ fastICA
        
$\textbf{4.}$ JADE method
        
$\textbf{5.}$ Infomax 


With the Random Uniform case, the distribution of signals is known to be two random uniform vectors, so it is desired to show that the ICA method can unmix the mixture matrix back into the original, known S.  Therefore, the plot ICA components should look very similar to the plot of the two random uniforms. 

(This test case has been adapted from the fastICA package Example 1)

[see @fastICA]




```{r,include=FALSE}
# Load necessary packages
library(fastICA)
library(JADE)
library(ica)
library(gridExtra)
library(tidyverse)
library(mosaic)
library(broom)
```

```{r,results="hide"}
set.seed(10) 
# Original source signals (usually unknown)
S <- matrix(runif(10000), 1000, 2) 
# Mixing matrix (usually unknown)
A <- matrix(c(1, 1, -1, 3), 2, 2, byrow = TRUE) 
# "Observed" mixture - always known
X <- S %*% A 

#ICA
a <- fastICA(X, 2, alg.typ = "parallel", fun = "logcosh", alpha = 1, 
             method = "C", row.norm = FALSE, maxit = 200, 
             tol = 0.0001, verbose = TRUE)

#JADE
b <- icajade(X,2,center=TRUE,maxit=200,tol=0.0001)

#Infomax
c <- icaimax(X,nc=2,center=TRUE,maxit=200,tol=0.0001,alg="newton",fun="log")
```



```{r, echo=FALSE}
par(mfrow = c(1, 3))
plot(S, main= "Plot of 2 Random Uniform")
plot(a$X, main = "Pre-processed data")
plot(a$X %*% a$K, main = "PCA components")

par(mfrow = c(1, 3))

plot(a$S, main = "ICA  fastICA")
plot(b$S,main="ICA Jade")
plot(c$S, main="ICA Infomax")

```

#### Plot Interpretation

Looking at these plots, the pre-processed data (plot of the constructed X) is rotated and no signals are clear from it.  

PCA appears to have flattened the data slightly and creates almost a mirror of the original data, but the true signals from the distributions still do not appear completely evident.  PCA does not effectively separate sources given how it rotates data.

However, looking at the ICA transformation,the shape of the original uniform distribution clearly forms after the decomposition.  ICA was able to recover the original signals quite easily in this simple simulation.  The results for all 3 ICA packages (JADE,Infomax and fastICA) appear to produce approximately the same plots for this example.



#### Congurence Coefficient of Source Signals

To get an idea of the underlying differences between these methods, the absolute maximum column value of the congruence coefficient of each un-mixing matrix can be calculated.

Tucker's Congruency Coefficient compares uncentered correlation between the columns of two matrices of the same dimensions.  The absolute value of max column of this coefficient is then taken. 

```{r}
colMax <- function(data) sapply(data, max, na.rm = TRUE)[1] #Function to find colMax 
Fast1 <- colMax(abs(congru(S,a$S)))
JADE1 <- colMax(abs(congru(S,b$S)))
Info1 <- colMax(abs(congru(S,c$S)))
```


```{r,echo=FALSE}
t1 <- data.frame(Method = c("fastICA","JADE","Infomax"), "Coef" = c(Fast1,JADE1,Info1))
colnames(t1) <- c("Method","Absolute Max Congruence Coef")
myTable <- table(t1)
myFrame <- as.data.frame(t1)
myFrame 
```

With just one dataset in this toy example,the results from the absolute maximum congruence coefficient test do not indicate accurately which algorithm will perform best overall. A higher value will indicate more similarities between the actual source matrix and the S generated by an ICA method.  Here JADE and Infomax seem to perform better, but this value needs to be replicated and tested with more noise to determine if fastICA is truly less effective on multiple datasets.  This computation will be done with the later simulation.

### (More) Complex Example: The Cocktail Party Problem

The most common example used to explain and motivate the use of ICA (or any type of BSS) is the "Cocktail Party Problem." 

Two (or more) microphones are placed in a room where to different people are speaking at the same time.  Each microphone signal is defined as $x_1(t)$ and $x_2(t)$, with some observed (i.e. known) amplitudes $x_1$ and $x_2$ with time as an index. The unknown speech signals of the speakers are denoted $s_1(t)$ and $s_2(t)$ to make up the following system of equations:

$$ x_1(t) = a_{11}s_1 +a_{12}s_2 $$

$$ x_2(t) = a_{21}s_1 +a_{22}s_2 $$

This can also be rewritten as:

$$x_i = \begin{bmatrix} x_1 \\ x_2 \end{bmatrix}$$ 
$$s_i = \begin{bmatrix} s_1 \\ s_2 \end{bmatrix}$$ 
$$A = \begin{bmatrix} a_{11} & a_{12} \\ a_{21} & a_{22}  \end{bmatrix}$$ 

If the weighted $a_{ij}$ was known, this problem could be easily solved but because it is not, ICA becomes a necessary tool




#### Example with Cocktail Party Data


A test example and simulation can be generated using the CPPdata from the JADE package that contains 50,000 observations from 4 different microphones. [@JADE]


A smaller sample of 10,000 is take here for graphical and calculation purposes.

```{r}
set.seed(40)
dat <- CPPdata[sample(10000),]
dat <- mutate(dat, count= 1:nrow(dat))
colnames(dat) <- c("x","y","z","t", "count") # sample to reduce noise
dat <- mutate(dat, count= 1:nrow(dat))
```

#### Original Source Signals

Unlike with the Random Uniform example, the true source signal matrix is unknown and the only information provided is the observed data.  Because of this, it makes sense to look at each column (different microphone) separately as a starting point.


```{r,echo=FALSE}
d1 <- select(dat,count,x)
d11 <- ggplot(d1, aes(y=x,x=count)) + geom_point() + labs(main="Microphone #1")

d2 <- select(dat, count, y)
d22 <- ggplot(d2, aes(y=y,x=count)) + geom_point() + labs(main="Microphone #2")


d3 <- select(dat, count, z)
d33 <- ggplot(d3, aes(y=z,x=count)) + geom_point() + labs(main="Microphone #3")


d4 <- select(dat, count, t)
d44 <- ggplot(d4, aes(y=t,x=count)) + geom_point() + labs(main="Microphone #4")

grid.arrange(d11,d22,d33,d44)
```

Each microphone has unique signal even to the point of quite variable means.

```{r,warning=FALSE, message=FALSE}
m <- fastICA(dat,2,alg.typ = "parallel", fun = "logcosh", alpha = 1, 
             method = "C", row.norm = FALSE, maxit = 200, 
             tol = 0.0001, verbose = TRUE)

n <- icajade(dat,4,center=TRUE,maxit=200,tol=0.0001)
o <- icaimax(dat,nc=4,center=TRUE,maxit=200,tol=0.0001,alg="newton",fun="log")
```



```{r, echo=FALSE}
par(mfrow = c(1,2))
plot(m$X, main = "Pre-processed data")
plot(m$X %*% m$K, main = "PCA components")

par(mfrow = c(1,3))

plot(m$S, main = "ICA components")
plot(n$S, main = "ICA JADE")
plot(o$S, main ="ICA Infomax")


```

#### Plot Interpretation


Again, the data appears to have a highly rotated set of pre-processed data and a PCA rotation that only transforms the data enough to separate the mixture ever so slightly.  



With ICA, a full rotation and a much cleaner shape begin to form, almost diamond-like. Like with the random uniform example, the superior performance of any one of the three ICA methods is not identifiable just from these primitive plots of the model.

Of note with the ICA algorithms example is the "nc" (number of components) input of the function for each of these different methods.  Particularly, both the JADE and Infomax produce similar plots at $nc=4$, which makes sense as the dataset $CPPdata$ has observations from 4 microphones.  However, to generate a similar plot for fastICA, $nc=2$ was used.  The results for $nc=4$ with ICA appear as below (JADE and Infomax shown at $nc=2$) for reverse comparison.

```{r,results="hide"}
S <- matrix(runif(10000), 1000, 2)
A <- matrix(c(1, 1, -1, 3), 2, 2, byrow = TRUE)
X <- S %*% A
m <- fastICA(dat,4,alg.typ = "parallel", fun = "logcosh", alpha = 1, 
             method = "C", row.norm = FALSE, maxit = 200, 
             tol = 0.0001, verbose = TRUE)
n <- icajade(dat,2,center=TRUE,maxit=200,tol=0.0001)

o <- icaimax(dat,nc=2,center=TRUE,maxit=200,tol=0.0001,alg="newton",fun="log")

par(mfrow = c(1,3))
plot(m$S, main = "ICA components")
plot(n$S, main = "ICA JADE")
plot(o$S, main ="ICA Infomax")
```


While JADE and Infomax at $nc=2$ do not differ greatly from $nc=4$, the fastICA plot appears more similar to the pre-processed data when the number of components is set at 4.

#### Congruence Coefficient of Source Signals

```{r,echo=FALSE}
Fast2 <- colMax(abs(congru(dat,m$S)))
JADE2 <- colMax(abs(congru(dat,n$S)))
Info2 <- colMax(abs(congru(dat,o$S)))

t2 <- data.frame(Method = c("fastICA","JADE","Infomax"), Coeff = c(Fast2,JADE2,Info2))
myTable <- table(t2)
myFrame <- as.data.frame(t2)
myFrame
```


For the CPP data, the congruence coefficient compares the this value between the observed data and generated source data, as the true $S$ is not known like in the Random Uniform case.  Thus, a lower value for our absolute max congruence coefficient should be optimal.  Again, running the ICA methods on more than one dataset will provide more robust results.





## Simulation

Given the simplistic nature of both toy examples, a simulation can provide more robust insight into the effectiveness of ICA in extracting original source components.


### Random Uniform Distribution Simulation

Adding noise to the Random Uniform example will be done by generating a noise vector from a random exponential distribution with $\lambda= 1$. This should inform how fastICA, JADE and Infomax perform when the Random Uniform data has been obscured further beyond the mixing matrix A. 

```{r}
n <- 1000
set.seed(10)
sim_S <- function(n,noise) { 
  U <- runif(n, 0,1)
  samples <- rep(0,n)
# Add noise from a Random Exponential Distribution with lambda = 1
  X <- rexp(n,1) 
  S <- runif(10000)
  for(i in 1:n) {
# Higher the noise value, the more we sample from noise vector
    if(U[i]<noise) { 
      samples[i] = X[i]


    }else {
      samples[i] = S[i]}

  }
    m.samples <- matrix(samples,N,2,byrow=T)
  return(m.samples)
  
}

```



```{r,results="hide", warning=FALSE}
N <- 1000

# Create 3 empty vectors for each ICA algorithm 
itF <- rep(NA,1,N) 
itJ <- rep(NA,1,N)
itM <- rep(NA,1,N)
JF <- rep(NA, 1,N)
A <- matrix(c(1, 1, -1, 3), 2, 2, byrow = TRUE)

#Function to find colMax of the generated congruencey coefficients

colMax <- function(data) sapply(data, max, na.rm = TRUE)[1] 

gen <- function(N,S, noise)  { 
#Inputs: number of interations,amount of noise,
# and source signal matrix 
  
  for (i in 1:N) {
    X[i] <- sim_S(N,noise) %*% A 
    a <- fastICA(X, 2, alg.typ = "parallel", fun = "logcosh", alpha = 1, 
                 method = "C", row.norm = FALSE, maxit = 200, 
                 tol = 0.0001, verbose = TRUE)
    b<- icajade(X,2,center=TRUE,maxit=200,tol=0.0001)
    
    c<- icaimax(X,nc=2,center=TRUE,maxit=200,tol=0.0001,
                alg="newton",fun="log")
    
# Store a Absolute Maximum Congruence Coefficient for 
# each N iteration of the ICA model
    itF[i] <- colMax(abs(congru(S,a$S)))
    itJ[i] <- colMax(abs(congru(S,b$S)))
    itM[i] <- colMax(abs(congru(S,c$S)))
    
# This compares Absolute Maximum Congruence Coefficient between fastICA and JADE
    
    JF[i] <- colMax(abs(congru(a$S,b$S)))

  }
  # Return a list of values from each method
  return(list(itF,itJ,itM,JF))
}

# Generate Coefficients for N datasets at multiple noise levels

I1 <- gen(N,S,0.05) # Noise = 0.05  Norm values 
I2 <- gen(N,S,0.10) # Noise = 0.10 Norm values
I3 <- gen(N,S,0.15) # Noise = 0.15 Norm values
NoNoise <- gen(N,S,0)  # Noise = 0 / No Noise

```

### Noise = 0 Results

```{r,echo=FALSE}
None <- data.frame(fastICA = NoNoise[[1]],JADE = NoNoise[[2]], Infomax = NoNoise[[3]],JadeFast = NoNoise[[4]])
None %>% 
  broom::tidy()
val1 <- favstats(NoNoise[[1]])[1]
val2 <- favstats(NoNoise[[4]])[4]
```

The expectation for the value of Absolute Maximum Congruence Coefficient for the noiseless model was for it to be high (eg. close to 1, the highest value) since the true S and the generated S by the algorithms should be similar. However, this was not the case, particularly for JADE and Infomax, as their means were below $0.10$ with SD of around $0.044$.  fastICA's mean was larger, but the SD was high at around $0.125$.

Thus, the Absolute Maximum Congruence Coefficient between fastICA and JADE was also calculated for a sanity check, and was found to be close to $0.51$ but also had a high standard deviation.  Interestingly, the median was actually close 1 at `r val2`, suggesting that the algorithms performed relatively similarly.

### Noise = 0.05 Results

```{r,echo=FALSE}
new1 <- data.frame(fastICA = I1[[1]],JADE = I1[[2]], Infomax = I1[[3]],JadeFast = I1[[4]])
new1 %>% 
  broom::tidy()
```

Unsurprisingly, the results when a small amount of noise was added to our data was essentially the same as for the NoNoise simulation.  However, it seems strange that the JADE and Infomax algorithms behaved more similar to each other for this model with some additional noise.

Again, comparing fastICA and JADE as an alternative approach, they appeared to perform about equally on this noisier model with a mean of $0.547$ and a median of $0.924$.

### Noise = 0.10 Results


```{r,echo=FALSE}
new2 <- data.frame(fastICA = I2[[1]],JADE = I2[[2]], Infomax = I2[[3]], JadeFast = I2[[4]])
new2 %>% 
  broom::tidy()
```

Both JADE and Infomax "improved" at the 0.10 noise level, and fastICA variability fell marginally.The fastICA JADE did not demonstrate the same success as the median value is only $0.407$, suggesting increased dissimilarity in results from the two methods.


### Noise = 0.15 Results


```{r,echo=FALSE}
new3 <- data.frame(fastICA = I3[[1]],JADE = I3[[2]], Infomax = I3[[3]],JadeFast = I3[[4]])
new3 %>% 
  broom::tidy()
```

Oddly enough, all three algorithms performed their best (largest mean value) on the 0.15 noise model, perhaps this indicates a need to run more iterations in order to recover more of the uniform distributions. Additionally, the random uniform may just have a high level of randomness for each dataset that does not allow the Absolute Maximum Congruence Coefficient to perform well.

Again, the JADE and fastICA comparison demonstrated that the performed roughly the same under these conditions.



## CPP Simulation: 

### Adding noise from Random Uniform


```{r, results="hide"}
x <- data(CPPdata)
set.seed(40)
dat <- CPPdata[sample(10000),]
mix <-matrix(runif(10000),10000,4)
N <- 10000
t <- rep(NA,4)

sim_CPP <- function(N,noise) {
  samples <- rep(0,N)
  t <- 1:4
  U <- runif(N,0,1)
  for(i in 1:N) {
      if(U[i]<noise) {
          samples[i] = runif(N,0,10)[i]

      }else {
          samples[i] = CPPdata[sample(N),sample(t)[1]]
      }
  }
    m.samples <- matrix(samples,N,4,byrow=T)
  return(m.samples)
}
```

```{r,results="hide",warning=FALSE}
N <- 500
C_S <- as.matrix(dat)[sample(N),]
itCF <- rep(NA,1,N)
itCJ <- rep(NA,1,N)
itCM <- rep(NA,1,N)
JF2 <- rep(NA,1,N)

gen_CPP <- function(N,S, noise)  {
  for (i in 1:N) {
    X <- sim_CPP(N,noise)
    m <- fastICA(X,2,alg.typ = "parallel", fun = "logcosh", alpha = 1, 
             method = "C", row.norm = FALSE, maxit = 200, 
             tol = 0.0001, verbose = TRUE)
    n <- icajade(X,4,center=TRUE,maxit=200,tol=0.0001)

    o <- icaimax(X,nc=4,center=TRUE,maxit=200,tol=0.0001,
                 alg="newton",fun="log")

    itCF[i] <- colMax(abs(congru(C_S,m$S)))
    itCJ[i] <- colMax(abs(congru(C_S,n$S)))
    itCM[i] <- colMax(abs(congru(C_S,o$S)))
    JF2[i] <- colMax(abs(congru(n$S,m$S)))

  }
  return(list(itCF,itCJ,itCM,JF2))
}
IC1 <- gen_CPP(N,C_S,0.05) # Noise = 0.05  
IC2 <- gen_CPP(N,C_S,0.10) # Noise = 0.10 
IC3 <- gen_CPP(N,C_S,0.15)  # Noise = 0.15 
NN2 <- gen_CPP(N,C_S,0)
```

### Noise = 0 Results

```{r, echo=FALSE}
nn2 <- data.frame(fastICA = NN2[[1]],JADE = NN2[[2]], Infomax = NN2[[3]],JadeFast = NN2[[4]])
nn2 %>% 
  broom::tidy()
```

The comparison by Absolute Maximum Congruence Coefficient for the CPP proves slightly more difficult since the true S is not known (comparison of congruence here is done between the data and generated S not known S as mentioned earlier).  Regardless, each algorithm performed very similarly (means within 0.0003 of each other) and had low standard deviation, thus the noiseless model seems to be relatively indifferent between the models.  The Jade and FastICA test resulted in a mean of $0.511$, suggesting relative similarity in the two methods.



### Noise = 0.05 Results

```{r, echo=FALSE}
new1 <- data.frame(fastICA = IC1[[1]],JADE = IC1[[2]], Infomax = IC1[[3]],JadeFast = IC1[[4]])
new1 %>% 
  broom::tidy()
```

Results for the lowest level of noise are even closer than in the noiseless model.  Jade and FastICA comparison performs slightly better in this case, suggesting closer performance.

### Noise = 0.10 Results

```{r, echo=FALSE}
new2 <- data.frame(fastICA = IC2[[1]],JADE = IC2[[2]], Infomax = IC2[[3]],JadeFast = IC2[[4]])
new2 %>% 
  broom::tidy()
```

Once again, all 3 algorithms produce almost identical means.  Jade to FastICA comparison is similar to prior comparisons.


### Noise = 0.15 Results

```{r, echo=FALSE}
new3 <- data.frame(fastICA = IC3[[1]],JADE = IC3[[2]], Infomax = IC3[[3]],JadeFast = IC3[[4]])
new3 %>% 
  broom::tidy()
```

The highest Noise threshold behaved most similarly to the noiseless, in terms of slightly more variability between algorithms.  The Jade to FastICA comparison behaved similarly to the Noise = 0.05 case.


### Method Effectiveness

In conclusion, differentiating between the various ICA model algorithms may not be particular important in analysis aside from wanting a use a particular non-Gaussian estimator or because of the need to control a certain parameter within the function.  Notably, JADE has fewer inputs than Infomax or fastICA, thus has more limited flexibility.  For the purposes of the rest of this paper, only the fastICA algorithm will be utilized. 






 